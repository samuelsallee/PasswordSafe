# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/signUp.ipynb (unless otherwise specified).

__all__ = ['logger', 'HelperError', 'ParseInputError', 'USERPASSWORDTABLE', 'Thread', 'H', 'EventInput', 'signUp']

# Cell
import hashlib, uuid, os, logging, sys
import ujson as json
from awsSchema.apigateway import Event,Response
from beartype import beartype
from copy import deepcopy
from pynamodb.models import Model
from pynamodb.attributes import (
    UnicodeAttribute, NumberAttribute, UnicodeSetAttribute, UTCDateTimeAttribute
)

# Cell
############### Logger for debugging code ##################
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.StreamHandler(sys.stdout))

# Cell
########## Error Definitions ##########
class HelperError(Exception): pass
class ParseInputError(HelperError): pass

# Cell
################ Setting Globals from Env Vars ################
USERPASSWORDTABLE = os.environ['USERPASSWORDTABLE']

# Cell
############## Class for accessing DynamoDB #################
class Thread(Model):
    class Meta:
        table_name = USERPASSWORDTABLE
        region = 'ap-southeast-1'

    username = UnicodeAttribute(hash_key=True, attr_name='username')
    passwordHash = UnicodeAttribute(range_key=True, attr_name='passwordHash')
    salt = UnicodeAttribute(attr_name='salt')
    hashAndSalt = UnicodeAttribute(attr_name='hashAndSalt')



# Cell
########## Helper class for main function ##########
EventInput = dict
class H:
    @staticmethod
    def sha256(password):
        return hashlib.sha256(password.encode()).hexdigest()

    @staticmethod
    def salt():
        return uuid.uuid4().hex

    @classmethod
    def salted_sha256(cls, password, salt=''):
        if salt == '':
            salt = cls.salt()
        return f'{cls.sha256(salt + password)}', f'{salt}'

    @staticmethod
    def add_user_to_table(username, hash, salt, hashAndSalt):
        userTable = os.environ['USERPASSWORDTABLE']
        threadItem = Thread(username=username, passwordHash=hash, salt=salt, hashAndSalt=hashAndSalt)
        threadItem.save()


    @staticmethod
    @beartype
    def parseInput(event: EventInput) -> tuple:
        '''
        returns path and filetype arguments from input
        '''
        body = Event.parseBody(deepcopy(event))
        try:
            username = body['username']
        except KeyError:
            logger.error('username is not in body')
            raise ParseInputError('username is not in body')

        try:
            password = body['password']
        except KeyError:
            logger.error('password is not in body')
            raise ParseInputError('password is not in body')

        return username, password

    @staticmethod
    def createTable():
        '''Cretaes the table if it doesn't exist'''
        if not Thread.exists():
            Thread.create_table(billing_mode='PAY_PER_REQUEST')

    @staticmethod
    def usernameAvailable(username):
        user = Thread.query(username)
        if len(user) > 0:
            return False
        return True


# Cell
def signUp(event, *args):

  logger.info(f"Password table name :: {USERPASSWORDTABLE}")

  evtCpy = deepcopy(event)
  logger.info(f'Event :: {evtCpy}')

  H.createTable()

  username, password = H.parseInput(evtCpy)
  # Take this away before using, it isn't a good idea to save the username and pw in logs
  logger.info(f"Username :: {username}\npassword :: {password}")

  hashedPw, salt = H.salted_sha256(password)
  hashAndSalt = hashedPw + ':' + salt
  logger.info(f'Hashed Pass :: {hashedPw}')

  if H.usernameAvailable(username):
    H.add_user_to_table(username, hashedPw, salt, hashAndSalt)

  return Response.returnSuccess("Success")

# Cell
# from beartype import beartype
# from awsSchema.apigateway import Response, Event
# from dataclasses import dataclass
# from dataclasses_json import dataclass_json
# from copy import deepcopy

# Cell
# from src import passwordHelper as PH
# from src.passwordTable import UserPasswordTable

# Cell
# @dataclass_json
# @dataclass
# class User:
#   username:str
#   password:str

#   @property
#   def passwordHash(self):
#     return PH.hashPassword(self.password)

#   def save(self):
#     table = UserPasswordTable(
#       username = self.username,
#       passwordHash = self.passwordHash
#     )
#     table.save()


# Cell
# class H:
#   class ParseInputError(Exception): pass
#   class SavingUserError(Exception): pass
#   @classmethod
#   @beartype
#   def parseInput(cls,event:dict)->User:
#     try:
#       user = Event.parseDataClass(User,deepcopy(event))
#       return user
#     except Exception as e:
#       raise cls.ParseInputError(e)

#   @classmethod
#   @beartype
#   def save(cls, user:User)->bool:
#     try:
#       user.save()
#       return True
#     except Exception as e:
#       raise cls.SavingUserError(e)




# Cell
# def signUp(event, *args):
#   try:
#     user = H.parseInput(event)
#     H.save(user)
#     return Response.returnSuccess()
#   except H.SavingUserError as e:
#     return Response.returnError(f'failed saving user {e}')
#   except Exception as e:
#     return Response.returnError(f'unknown error {e}')